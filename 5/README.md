CHAPTER 5: 일관성 해싱(Consistent Hashing) 설계
수평 확장(Scale-out)을 위해 요청/데이터를 균등하게 분산하는 것이 중요
일관성 해싱(Consistent Hashing) 은 이를 효과적으로 해결하는 대표적인 기법

Rehashing 문제 (서버 추가 시 문제 발생)
서버 개수가 변경될 때 기존 키 할당이 거의 모두 변경됨

서버 추가 후 (N=5) → 키 재배치 문제 발생

![image](https://github.com/user-attachments/assets/02dae41d-94be-4b4c-be43-33586de05a04)

서버 4대를 사용하던 환경에서 서버 1대를 추가(N=5) 하면, 기존 해시 값이 변경됨
예를 들어, hash(key0) % 4 = 1 → hash(key0) % 5 = 4 (서버 1 → 서버 4 이동)
거의 모든 키의 서버 할당이 변경됨 → 대량의 데이터 이동 발생

기존 방식의 문제점

대규모 데이터 마이그레이션 필요 (서버 추가/삭제 시 대부분의 키 이동)
캐시 히트율(Cache Hit Rate) 급감 (캐시 데이터가 무효화됨)
네트워크 부하 증가 (데이터 재배치 작업으로 인한 오버헤드)

![image](https://github.com/user-attachments/assets/e0d0e621-bbcf-4b7c-a491-cda1aab45f56)

서버가 제거될 때의 문제
예를 들어 서버 1이 오프라인이 되면 서버 풀의 크기가 4에서 3으로 감소하게 되며, 모듈 해시 함수(hash(key) % N)는 같은 키에 대해서도 다른 결과를 생성

![image](https://github.com/user-attachments/assets/e8af368d-9260-4c37-9467-1a8bae58758c)

![image](https://github.com/user-attachments/assets/48c079c6-b357-418c-bff9-3f74be9860ca)

일관된 해싱 (Consistent Hashing)
위키백과에서의 인용:
"일관된 해싱은 해시 테이블 크기가 변경되었을 때, 평균적으로 k/n개의 키만 다시 매핑하면 되는 특별한 종류의 해싱입니다. 
여기서 k는 키의 수, n은 슬롯의 수를 의미합니다. 반대로 전통적인 해시 테이블에서는 배열 슬롯의 수가 변경될 때 거의 모든 키가 다시 매핑되어야 합니다."

해시 공간과 해시 링

![image](https://github.com/user-attachments/assets/a0f6dd6d-51c3-402c-a558-84ab7560feef)

해시 공간 : SHA-1 헤시 함수 일 때, 0에서 2^160 - 1까지의 값 

![image](https://github.com/user-attachments/assets/d7fd9718-43c7-40ef-87db-743f58cbd177)

해시 링 : 해시 공간을 시각 적으로 링으로 표현

![image](https://github.com/user-attachments/assets/321ff320-8504-468d-8099-372bf998b311)

서버 추가 (Add a Server)
서버를 추가하면, 키의 재분배는 전체 키 중 일부만 필요
Consistent Hashing 알고리즘을 사용하면 서버 수의 변화가 최소화된 영향

Figure 5-8에서 볼 수 있듯이, 새로운 서버 4가 추가된 후, key0만 재분배됩니다. key1, key2, key3는 여전히 기존 서버들에 남음

구체적인 동작 설명
서버 4가 추가되기 전에는 key0가 서버 0에 저장
서버 4가 추가된 후, key0는 서버 4로 이동. 해시 링에서 key0의 위치에서 시계방향으로 가다가 처음 만나는 서버가 서버 4.

key1, key2, key3는 여전히 기존 서버에 저장

장점
효율적인 서버 확장: 새로운 서버가 추가될 때, 기존의 데이터는 그대로 유지되고, 추가된 서버가 담당하는 데이터만 재분배
최소화된 재배치: 모든 키를 다시 분배하는 대신, 일부 키만 재분배되므로 서버 수가 증가해도 데이터 이동이 최소화

![image](https://github.com/user-attachments/assets/4e22ef52-2029-47f2-97a4-a22dd58aded9)

서버 제거 (Remove a Server)
서버를 제거할 때도 Consistent Hashing 알고리즘은 재분배되는 키의 수를 최소화하는 특징
Figure 5-9에서 볼 수 있듯이, 서버 1이 제거될 경우, key1만 서버 2로 재분배. 다른 키들인 key0, key2, key3는 그대로 유지

구체적인 동작 설명
서버 1이 제거되면, key1은 더 이상 서버 1에서 찾을 수 없으므로, key1은 서버 2로 재분배. 이는 해시 링에서 key1이 서버 1 이후에 시계방향으로 가장 가까운 서버인 서버 2에 배정.
나머지 키들인 key0, key2, key3는 서버 1을 사용하고 있지 않기 때문에 그대로 남음

![image](https://github.com/user-attachments/assets/8955d2a5-2ad2-4fed-b869-3c46b18e3e53)

두 가지 문제점: 기본 접근 방식의 한계
Consistent Hashing 알고리즘은 MIT의 Karger et al.에 의해 소개되었으며, 이 알고리즘의 기본 동작은 다음과 같음
서버와 키를 링에 매핑하기 위해 균등하게 분포된 해시 함수를 사용
키가 매핑된 서버를 찾기 위해서는 키의 위치에서 시계방향으로 이동하면서 첫 번째 서버를 탐색

하지만 이 접근 방식에서 두 가지 문제가 발생할 수 있음

1. 서버의 파티션 크기 불균등
Consistent Hashing에서는 서버가 추가되거나 제거될 때 각 서버가 할당받는 파티션 크기가 동일하지 않을 수 있음
Figure 5-10에서, 서버 1이 제거되었을 때 서버 2의 파티션(양방향 화살표로 강조 표시된 영역)이 서버 0과 서버 3의 파티션보다 두 배 더 큼.
이는 Consistent Hashing에서 파티션 크기가 서버 간에 불균형적으로 분배될 수 있음을 의미

문제의 원인:
서버가 추가되거나 제거되면, 파티션의 크기가 고르게 분배되지 않기 때문에 일부 서버는 너무 작은 파티션을 할당받고, 일부 서버는 너무 큰 파티션을 할당받을 수 있음

2. 서버 추가 및 제거로 인한 리소스 재분배의 불균형
서버가 추가되거나 제거되면, 이로 인해 해시 링에 있는 키들이 다시 분배되지만, 이 과정에서 서버 간 파티션 크기의 차이가 발생할 수 있음

![image](https://github.com/user-attachments/assets/df5d0a0c-6c3b-4f86-93d3-106cb4d27d8c)

비균등한 키 분포 문제
두 번째 문제는 키 분포의 불균형
Consistent Hashing에서는 해시 링에 서버를 매핑하고, 키는 해당 서버가 있는 위치에 할당
서버 2에 대부분의 키가 저장되어 있으며, 서버 1과 서버 3은 데이터가 하나도 없음

문제의 원인:
해시 링의 특정 구간에만 서버가 위치하게 되면, 해당 구간에 키가 집중될 수 있음

![image](https://github.com/user-attachments/assets/12dfde82-52b6-40fa-b4af-ef10dd4242cf)

가상 노드 (Virtual Nodes)
가상 노드는 실제 서버를 여러 개의 가상 노드로 나타내는 기법
이 방식은 서버들이 해시 링에 고르게 분배되지 않는 문제를 해결

예시:
Figure 5-12에서 서버 0과 서버 1은 각각 3개의 가상 노드를 가짐 
이 가상 노드들의 번호는 s0_0, s0_1, s0_2로 나타낼 수 있음
이 방식은 서버가 물리적으로 하나이지만, 가상적으로는 여러 개의 서버처럼 동작하는 구조

작동 방식:
서버의 역할: 각 가상 노드는 서버의 실제 역할을 여러 개의 구간에 분배
서버 0이 s0_0, s0_1, s0_2라는 3개의 가상 노드로 나뉘어 해시 링에 매핑되면, 서버 0은 해당 가상 노드들이 관리하는 여러 개의 파티션을 담당

파티션 관리: 각 파티션(링의 구간)은 특정 서버가 관리
s0로 레이블이 붙은 파티션은 서버 0이, s1로 레이블이 붙은 파티션은 서버 1이 관리

![image](https://github.com/user-attachments/assets/4a48de27-804d-4c22-9ff8-4b383cd65a56)

키의 위치에서 시작하여 시계방향으로 진행하면서 가장 먼저 만나는 가상 노드가 해당 키를 관리하는 서버를 나타냄

![image](https://github.com/user-attachments/assets/a621c07c-95ee-46d4-8d51-d27ea6684dab)

가상 노드 수와 데이터 분배의 균형

가상 노드의 수가 증가하면, 해시 링에서 키의 분배가 더욱 균형 있게 됨

실험 결과:
온라인 연구에서 실시된 실험에 따르면, 200개의 가상 노드를 사용할 경우 표준 편차는 5% 정도로 나타났고, 100개의 가상 노드를 사용할 경우 **10%**의 표준 편차가 발생

가상 노드의 수와 성능 간의 트레이드오프: 가상 노드 수가 많을수록 분배는 더 균등해지지만, 그만큼 더 많은 공간을 차지하고, 저장 관리의 비용이 증가

최적화:
가상 노드 수 조정: 시스템 요구사항에 맞게 가상 노드 수를 조정
예를 들어, 성능 최적화가 중요한 시스템에서는 가상 노드 수를 늘려서 데이터 분배의 균형을 맞출 수 있고, 반대로 저장 비용이 중요한 경우에는 가상 노드 수를 줄일 수 있음

서버가 추가되거나 제거될 때, 영향을 받는 키들을 정확히 파악하려면, 해시 링에서 반시계방향으로 범위를 추적하여 그 범위에 속한 키들을 새 서버로 이동하거나 기존 서버로 재배치

![image](https://github.com/user-attachments/assets/2f4eb295-849f-4fe1-a4e7-8f0a3c91c04f)

서버 s1이 제거될 때, s0와 s1 사이의 모든 키들이 s2로 이동하며, 시스템 내에서 영향을 받는 키들만 재분배되므로 시스템에 미치는 영향을 최소화

![image](https://github.com/user-attachments/assets/8eaed0f2-db09-4416-8767-b2bd9a93929e)
